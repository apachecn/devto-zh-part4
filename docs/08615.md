# åŸºäºå±æ€§çš„æµ‹è¯•:ä» Erlang/Elixir åˆ° Clojure

> åŸæ–‡:[https://dev . to/Shao lang/property-based-testing-from-Erlang-elixir-to-clo jure-57nm](https://dev.to/shaolang/property-based-testing-from-erlang-elixir-to-clojure-57nm)

é˜…è¯»[PropErã€Erlang å’Œ Elixir](https://pragprog.com/book/fhproper/property-based-testing-with-proper-erlang-and-elixir) çš„åŸºäºå±æ€§çš„æµ‹è¯•å¹¶è·Ÿéšç¤ºä¾‹å¸®åŠ©æˆ‘å­¦ä¹ äº†è¿™ç§ä»¤äººå…´å¥‹çš„æµ‹è¯•æ–¹æ³•ï¼›ä½†è¿™ä¹Ÿè®©æˆ‘æ„Ÿåˆ°ç–‘æƒ‘:æˆ‘çœŸçš„é€šè¿‡è·Ÿéšè€Œå¸æ”¶å¹¶å†…åŒ–äº†*å—ï¼Ÿ*

å› æ­¤ï¼Œæˆ‘è”ç³»äº† [Fred](https://twitter.com/mononcqc) ï¼Œå¾—åˆ°äº†ä»–çš„åŒæ„ï¼Œå¹¶å¼€å§‹ç”¨ [test.check](https://github.com/clojure/test.check) å°†ä»£ç ä» Erlang/Elixir ç¿»è¯‘æˆ Clojureã€‚æ‰€æœ‰[åˆ°ç›®å‰ä¸ºæ­¢]å®Œæˆçš„ä»£ç éƒ½æ‰˜ç®¡åœ¨ https://github.com/shaolang/pbtic çš„æˆ‘æ­£åœ¨ä½¿ç”¨ [test.check](https://github.com/clojure/test.check) ä½œä¸º Clojure ä¸­åŸºäºå±æ€§çš„æµ‹è¯•å·¥å…·ã€‚

## [](#birthday-greeting-kata)ç”Ÿæ—¥é—®å€™å½¢

è¯¥ä¹¦å°† kata åˆ†è§£ä¸º 4 ä¸ªéƒ¨åˆ†: [CSV è§£æ](#csv-parsing)ã€[è®°å½•è¿‡æ»¤](#records-filtering)ã€[å‘˜å·¥æ¨¡å—](#employee-module)(æ¡¥æ¥ CSV è§£æå’Œè®°å½•è¿‡æ»¤)ã€ä»¥åŠ[é‚®ä»¶æ¨¡æ¿](#email-templating)ã€‚

### [](#csv-parsing)CSV è§£æ

```
(ns  pbtic.birthday.csv-test  (:require  [clojure.test  :refer  [deftest  is]]  [clojure.test.check.clojure-test  :refer  [defspec]]  [clojure.test.check.generators  :as  gen]  [clojure.test.check.properties  :refer  [for-all]]  [pbtic.birthday.csv  :as  csv]))  ;;;;;;;  ;; defs  (def  ^:private  text-data  (str  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"  ":;<=>?@ !#$%&'()*+-./[\\]^_`{|}~"))  ;;;;;;;;;;;;;  ;; generators  (defn-  text  [cs]  (gen/let  [xs  (gen/list  (gen/elements  cs))]  (apply  str  xs)))  (def  unquoted-text  (text  text-data))  (def  quotable-text  (text  (str  text-data  "\r\n\",")))  (def  field  (gen/one-of  [unquoted-text,  quotable-text]))  (def  header  (partial  gen/vector  field))  (def  record  (partial  gen/vector  field))  (defn  entry  [size  ks]  (gen/let  [vs  (record  size)]  (zipmap  ks  vs)))  (def  csv-source  (gen/let  [size  gen/pos-int  ks  (header  (inc  size))]  (gen/list  (entry  (inc  size)  ks)))) 
```

ä¸[ä¸­çš„`?LET` / `let`ä¸åŒï¼Œé€‚å½“çš„](https://github.com/proper-testing/proper) / [PropCheck](https://github.com/alfert/propcheck) ï¼Œ
[`clojure.test.check.generators/let`](http://clojure.github.io/test.check/clojure.test.check.generators.html#var-let) å¯ä»¥æœ‰å¤šä¸ªç»‘å®šï¼Œå…¶ä¸­ç»‘å®šä¹‹åå¯ä»¥å¼•ç”¨å‰ä¸€ä¸ªçš„å€¼ï¼Œå¦‚ç¬¬ 39 å’Œ 40 è¡Œæ‰€ç¤ºã€‚

`csv-source`ç”Ÿæˆä¸€ä¸ªæ˜ å°„åˆ—è¡¨ï¼Œå…¶ä¸­æ¯ä¸ªæ˜ å°„æ˜¯æ¥è‡ª CSV æºçš„ä¸€ä¸ªè®°å½•ï¼Œæ¯ä¸ªæ˜ å°„çš„é”®æ˜¯å¤´è®°å½•ã€‚è™½ç„¶ Clojure maps ä¹ æƒ¯ä½¿ç”¨å…³é”®å­—ä½œä¸ºæ˜ å°„çš„é”®ï¼Œä½†è¯¥ä¹¦å»ºè®®å°† CSV è§£æé›†ä¸­åœ¨ç¼–ç /è§£ç ä¸Šï¼Œä¸è¦å¼•å…¥ä»»ä½•ä¸šåŠ¡éœ€æ±‚æ¥ä¿æŒæ¨¡å—/åç§°ç©ºé—´çš„å¯ç»´æŠ¤æ€§ã€‚

```
;;;;;;;;;;;;;  ;; properties  (defspec  roundtrip-encoding-decoding  (for-all  [maps  csv-source]  (=  maps  (csv/decode  (csv/encode  maps)))))  ;;;;;;;;  ;; tests  (deftest  one-column-csv-files-are-inherently-ambiguous  (is  (=  "\r\n\r\n\r\n"  (csv/encode  [{""  ""},  {""  ""}])))  (is  (=  [{""  ""}]  (csv/decode  "\r\n\r\n"))))  (deftest  one-record-per-line  (is  (=  [{"aaa"  "zzz",  "bbb"  "yyy",  "ccc"  "xxx"}]  (csv/decode  "aaa,bbb,ccc\r\nzzz,yyy,xxx\r\n"))))  (deftest  optional-trailing-crlf  (is  (=  [{"aaa"  "zzz",  "bbb"  "yyy",  "ccc"  "xxx"}]  (csv/decode  "aaa,bbb,ccc\r\nzzz,yyy,xxx"))))  (deftest  double-quotes  (is  (=  [{"aaa"  "zzz",  "bbb"  "yyy",  "ccc"  "xxx"}]  (csv/decode  "\"aaa\",\"bbb\",\"ccc\"\r\n\"zzz\",\"yyy\",\"xxx\""))))  (deftest  escape-crlf  (is  (=  [{"aaa"  "zzz",  "b\r\nbb"  "yyy",  "ccc"  "xxx"}]  (csv/decode  "\"aaa\",\"b\r\nbb\",\"ccc\"\r\nzzz,yyy,xxx"))))  (deftest  double-quotes-escaping  (is  (=  [{"aaa"  "",  "b\"bb"  "",  "ccc"  ""}]  (csv/decode  "\"aaa\",\"b\"\"bb\",\"ccc\"\r\n,,"))))  (deftest  dupe-keys-unsupported  (let  [csv  (str  "field_name,field_name,field_name\r\n"  "aaa,bbb,ccc\r\n"  "zzz,yyy,xxx\r\n")  [m1  m2]  (csv/decode  csv)]  (is  (=  ["field_name"]  (keys  m1)))  (is  (=  ["field_name"]  (keys  m2))))) 
```

å±æ€§å’Œæµ‹è¯•ç›´æ¥åæ˜ äº†ä¹¦ä¸­çš„åŸå§‹ä»£ç ã€‚ä½†æ˜¯å®ç°å‘¢ï¼Ÿå“ˆå“ˆï¼Œæˆ‘èµ°äº†æ·å¾„ï¼Œç”¨ [data.csv](https://github.com/clojure/data.csv) ä»£æ›¿ï¼Œå› ä¸ºæˆ‘çš„ä¸»è¦ç›®çš„æ˜¯å­¦ä¹ å¦‚ä½•ç¼–å†™å±æ€§æµ‹è¯•ï¼Œè€Œä¸æ˜¯å®ç° csv è§£æå™¨ã€‚

```
(ns  pbtic.birthday.csv  (:require  [clojure.data.csv  :as  csv]  [clojure.string  :as  str]))  (defn  encode  [ms]  (let  [ks  (->  ms  first  keys)  vs  (map  vals  ms)  out  (java.io.StringWriter.)]  (csv/write-csv  out  (conj  vs  ks)  :newline  :cr+lf)  (.toString  out)))  (defn  decode  [s]  (let  [[header  &  body]  (csv/read-csv  (java.io.StringReader.  s))]  (map  (partial  zipmap  header)  body))) 
```

## [](#records-filtering)è®°å½•è¿‡æ»¤

è®°å½•è¿‡æ»¤æ¨¡å—/åç§°ç©ºé—´è¿‡æ»¤ç”Ÿæ—¥åœ¨ç»™å®šæ—¥æœŸçš„é›‡å‘˜ã€‚è™½ç„¶å±æ€§æ˜¯æ–°å‘ç°çš„åŠ›é‡ï¼Œä½†æ˜¯åœ¨è¿™ä¸ªå®ä¾‹ä¸­ä½¿ç”¨å®ƒä»¬å¯èƒ½å¹¶ä¸åˆé€‚ï¼Œå› ä¸ºå±æ€§æµ‹è¯•çš„æ ¸å¿ƒæ˜¯æ¦‚ç‡æ€§çš„ã€‚â€œä¼ ç»Ÿçš„â€å•å…ƒæµ‹è¯•å¯ä»¥æ›´å¥½åœ°æ¢ç´¢è¿™ä¸ªé—®é¢˜ç©ºé—´ã€‚å³ä¾¿å¦‚æ­¤ï¼ŒFred å»ºè®®è¿è¡Œä¸€ä¸ªè¯¦å°½çš„æœç´¢æ¥è¦†ç›–æ‰€æœ‰å¯èƒ½çš„æ¡ˆä¾‹ï¼Œåœ¨åŸºäºå±æ€§çš„æµ‹è¯•ä¸­ä½¿ç”¨ç”Ÿæˆå™¨ä½œä¸ºâ€œç”Ÿæˆâ€æ¡ˆä¾‹çš„çµæ„Ÿã€‚

```
(ns  pbtic.birthday.bday-filter-test  (:require  [pbtic.birthday.bday-filter  :as  filter  :refer  [month-day]]  [clojure.set  :as  set]  [clojure.test  :refer  [deftest  is]])  (:import  [java.time  DateTimeException  LocalDate]))  ;;;;;;;;;;  ;; helpers  (defn  find-birthdays-for-year  [people  yeardata]  (when  (seq  yeardata)  (let  [[day  &  year]  yeardata  found  (filter/birthday  people  day)]  ;; <- function being tested  (assoc  (find-birthdays-for-year  people  year)  day  found))))  (defn  generate-year-data  [start]  (let  [start-date  (LocalDate/of  start  1  1)  end-date  (LocalDate/of  (inc  start)  1  1)]  (into  []  (..  start-date  (datesUntil  end-date)  toArray))))  (defn  generate-years-data  [start  end]  (mapv  generate-year-data  (range  start  (inc  end))))  (defn  rand-name  []  (apply  str  (repeatedly  30  #(rand-nth  "abcdefghijklmnopqrstuvwxyz"))))  (defn  people-for-date  [date]  (try  (let  [[month  day]  (month-day  date)  rand-year  (+  1900  (rand-int  100))]  {:name  (rand-name)  :date-of-birth  (LocalDate/of  rand-year  month  day)})  (catch  Exception  _  (people-for-date  date))))  (defn  people-for-year  [year]  (map  people-for-date  year))  (defn  generate-people-for-year  [n]  (let  [year-seed  (generate-year-data  2016)]  ;; leap year so all days are covered  (mapcat  (fn  [_]  (people-for-year  year-seed))  (range  n))))  ;;;;;;;;;;;;;  ;; assertions  (defn  every-birthday-once  [people  birthdays]  (let  [found  (mapcat  second  birthdays)  not-found  (set/difference  (set  people)  (set  found))]  (is  (empty?  not-found))  (is  (zero?  (-  (count  found)  (count  (set  found)))))))  (defn  on-right-date  [people  birthdays]  (doseq  [[date  found]  birthdays  {:keys  [date-of-birth]}  found]  (let  [[dob-month  dob-day]  (month-day  date-of-birth)]  (try  (LocalDate/of  (.getYear  date)  dob-month  dob-day)  (is  (=  (month-day  date)  (month-day  date-of-birth)))  (catch  DateTimeException  _  true)))))  ;;;;;;;  ;; test  (deftest  property-style-filtering  (let  [years  (generate-years-data  2018  2038)  people  (generate-people-for-year  3)]  (doseq  [yeardata  years]  (let  [birthdays  (find-birthdays-for-year  people  yeardata)]  (every-birthday-once  people  birthdays)  (on-right-date  people  birthdays))))) 
```

è¿™ä¸ªå’ŒåŸæ¥çš„åŒºåˆ«æ˜¯:

*   `generate-year-data`(ç¬¬ 17-20 è¡Œ)æ˜æ˜¾æ¯”åŸæ¥çš„è¦çŸ­ï¼Œå› ä¸ºå®ƒä½¿ç”¨äº† [`java.time.LocalDate#datesUntil`](https://docs.oracle.com/javase/9/docs/api/java/time/LocalDate.html#datesUntil-java.time.LocalDate-) æ–¹æ³•æ¥ç”Ÿæˆæ—¥æœŸã€‚ä¹¦ä¸­çš„ Elixir ç‰ˆæœ¬å¾ˆé•¿ï¼Œå¯èƒ½æ˜¯å› ä¸º Fred æƒ³è®©å®ƒä¸ Erlang ç‰ˆæœ¬ä¿æŒä¸€è‡´ï¼›å¦‚æœä»–ä½¿ç”¨ä»™ä¸¹çš„ Date.range/2 åŠŸèƒ½(Erlang ä¸­æ²¡æœ‰ç±»ä¼¼çš„åŠŸèƒ½ğŸ˜­)ï¼Œä»£ç ä¼šæ›´çŸ­ï¼Œå¦‚ä¸‹æ‰€ç¤º:

```
defp generate_year_data(year) do
  {:ok, start_date} = Date.new(year, 1, 1)
  {:ok, end_date} = Date.new(year, 12, 31)

  Date.range(start_date, end_date)
  |> Enum.into([])
end 
```

*   `rand-name`(ç¬¬ 27-28 è¡Œ)æ˜¯ Erlang çš„`make-ref/0`çš„ç®€å•æ›¿èº«ã€‚
*   `every-birthday-once`(ç¬¬ 51-55 è¡Œ)ä½¿ç”¨é›†åˆæ•°æ®ç»“æ„ç¡®å®šæœªæ‰¾åˆ°çš„äººå‘˜é›†åˆã€‚
*   `on-right-date`(ç¬¬ 58-66 è¡Œ)æ•æ‰æ— æ•ˆçš„æ—¥æœŸï¼Œå¹¶åœ¨ catch å­å¥ä¸­è¿”å›`true`ä»¥è¡¨ç¤ºâ€œè·³è¿‡â€ï¼Œå› ä¸º Clojure ä¸åƒ Erlang/Elixir é‚£æ ·é¢‘ç¹åœ°ä½¿ç”¨æ¨¡å¼åŒ¹é…ã€‚

`pbtic.birthday.bday-filter`çš„å®ç°å¦‚ä¸‹:

```
(ns  pbtic.birthday.bday-filter)  (def  month-day  (juxt  #(.getMonthValue  %)  #(.getDayOfMonth  %)))  (defn  birthday-no-leap-year-handling  [people  date]  (let  [md  (month-day  date)]  (filter  #(=  (month-day  (:date-of-birth  %))  md)  people)))  (defn  filter-dob  [people  month  day]  (filter  #(=  (month-day  (:date-of-birth  %))  [month  day])  people))  (defn  birthday  [people  date]  (let  [[month  day]  (month-day  date)]  (if  (and  (=  [month  day]  [2  28])  (not  (.isLeapYear  date)))  (concat  (filter-dob  people  2  28)  (filter-dob  people  2  29))  (filter-dob  people  month  day)))) 
```

`birthday-no-leap-year-handling`(ç¬¬ 7-9 è¡Œ)æ˜¾ç¤ºäº†å¤„ç†éé—°å¹´çš„ 2 æœˆ 29 æ—¥ç”Ÿæ—¥ä¹‹å‰çš„ä»£ç (å…¬å¸ä¸åº”è¯¥æ¯å››å¹´æ‰ç¥ä»–ä»¬ä¸€æ¬¡ç”Ÿæ—¥å¿«ä¹ï¼Œä¸æ˜¯å—ï¼Ÿ).

### [](#employee-module)å‘˜å·¥æ¨¡å—

å‘½åç©ºé—´æ¥ç»Ÿæ²»ä»–ä»¬æ‰€æœ‰äººğŸ’ï¼›å®ƒå°†`pbtic.birthday.csv`å’Œ`pbtic.birthday.bday-filter`è”ç³»åœ¨ä¸€èµ·ã€‚è¿™ä¸ªåç§°ç©ºé—´ä¸­çš„å‡½æ•°å®ç°äº†å…¶ä»–åç§°ç©ºé—´å¯èƒ½è¿˜æ²¡æœ‰çš„ä¸šåŠ¡éœ€æ±‚ï¼Œä¾‹å¦‚`pbtic.birthday.csv`ä¸­çš„ CSV è§£æå™¨ã€‚

```
(ns  pbtic.birthday.employee-test  (:require  [clojure.string  :as  str]  [clojure.test.check.clojure-test  :refer  [defspec]]  [clojure.test.check.generators  :as  gen]  [clojure.test.check.properties  :refer  [for-all]]  [pbtic.birthday.csv-test  :as  csv-test]  [pbtic.birthday.employee  :as  employee])  (:import  [java.time  LocalDate]))  ;;;;;;;  ;; defs  (def  start-date  (LocalDate/of  1900  1  1))  (def  max-days  (..  start-date  (until  (LocalDate/of  2021  1  1))  getDays))  ;;;;;;;;;;;;;  ;; generators  (def  text-date  (gen/let  [days-to-add  (gen/choose  0  max-days)]  (let  [date  (.plusDays  start-date  days-to-add)]  (format  " %4d/%02d/%02d"  (.getYear  date)  (.getMonthValue  date)  (.getDayOfMonth  date)))))  (def  whitespaced-text  (gen/let  [txt  csv-test/field]  (str  " "  txt)))  (def  raw-employee-map  (gen/let  [val-list  (gen/tuple  csv-test/field  whitespaced-text  text-date  whitespaced-text)]  (zipmap  ["last_name",  " first_name",  " date_of_birth",  " email"]  val-list)))  ;;;;;;;;;;;;;  ;; properties  (defspec  check-that-leading-space-is-fixed  (for-all  [m  raw-employee-map]  (let  [emp  (employee/adapt-csv-result  m)]  (every?  #(not  (str/starts-with?  (name  %)  " "))  (concat  (keys  emp)  (filter  string?  (vals  emp)))))))  (defspec  check-that-date-is-formatted-right  (for-all  [m  raw-employee-map]  (let  [m  (employee/adapt-csv-result  m)]  (=  (type  (get  m  :date-of-birth))  LocalDate)))) 
```

æ ¹æ® Fred çš„å»ºè®®ï¼Œåœ¨åˆ›å»ºè‡ªå®šä¹‰ç”Ÿæˆå™¨æ—¶ï¼Œå°†ä¸€ä¸ªé™åˆ¶é‡æ–°è½¬æ¢ä¸ºä¸€ä¸ªè½¬æ¢(å‚è€ƒæœ¬ä¹¦ç¬¬ 4 ç« åŸºæœ¬è‡ªå®šä¹‰ç”Ÿæˆå™¨ä¸‹çš„å¼ºåŠ é™åˆ¶å°èŠ‚)ï¼Œ`text-date`(ç¬¬ 22-28 è¡Œ)æŠ›å¼ƒ`gen/such-that`å¹¶è¿›è¡Œä¸€ä¸ªå°†å¤©æ•°æ·»åŠ åˆ°å·²çŸ¥å¼€å§‹æ—¥æœŸ(1900-01-01)çš„è½¬æ¢ã€‚è™½ç„¶è¿™ä¸æ˜¯ä¸€ä¸ªçº¯ç²¹çš„ä»£ç ç§»æ¤ï¼Œä½†å®ƒè¡¨æ˜é‡æ–°æƒ³è±¡æ‰‹å¤´çš„é—®é¢˜å¹¶ä¸é‚£ä¹ˆå›°éš¾ã€‚

```
(ns  pbtic.birthday.employee  (:require  [clojure.string  :as  str]  [pbtic.birthday.bday-filter  :as  bday-filter]  [pbtic.birthday.csv  :as  csv])  (:import  [java.time  LocalDate]  [java.time.format  DateTimeFormatter]))  ;;;;;;;  ;; defs  (def  ^:private  datetime-formatter  (DateTimeFormatter/ofPattern  "yyyy/MM/dd"))  ;;;;;;;;;;;;;  ;; public API  (defn  adapt-csv-result  [m]  (let  [ks  (sequence  (comp  (map  str/triml)  (map  #(str/replace  %  #"_"  "-"))  (map  keyword))  (keys  m))  m  (zipmap  ks  (map  str/triml  (vals  m)))  dob  (:date-of-birth  m)]  (assoc  m  :date-of-birth  (LocalDate/parse  dob  datetime-formatter))))  (defn  from-csv  [s]  (map  adapt-csv-result  (csv/decode  s)))  ;; parameter order is different from the book's  (defn  filter-birthday  [date  employees]  (bday-filter/birthday  employees  date)) 
```

åç§°ç©ºé—´æ²¡æœ‰å®ç°â€œè®¿é—®å™¨â€,å› ä¸ºç¬¬ 19 è¡Œçš„å…³é”®å­—åŒ–æ˜¯å› ä¸º Clojure çš„ä¹ è¯­ä½¿ç”¨å…³é”®å­—ä»æ˜ å°„ä¸­æ£€ç´¢å€¼(ç¬¬ 22 è¡Œæ˜¾ç¤ºäº†ä¸€ä¸ªè¿™æ ·çš„ä¾‹å­)ã€‚å¦ä¸€ä¸ªå˜åŒ–æ˜¯äº¤æ¢äº†`filter-birthday`ä¸­çš„å‚æ•°(ç¬¬ 31-32 è¡Œ)ï¼›è¿™ä½¿å¾—è¯¥åŠŸèƒ½æ›´å®¹æ˜“ä¸ [`->>`](https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-%3E%3E) çº¿ç¨‹å®ä¸€èµ·ä½¿ç”¨ï¼›Elixir [`|>`](https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2) æœŸæœ›é›†åˆæ˜¯ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œä½†æ˜¯ Clojure `->>`æœŸæœ›å®ƒæ˜¯æœ€åä¸€ä¸ª)ã€‚è¿™æ ·çš„çœç•¥ä½¿å¾— Clojure çš„å®ç°/ç«¯å£æ›´çŸ­ã€‚

### [](#templating)æ¨¡æ¿åŒ–

`pbtic.birthday.mail-tpl/body`åŠŸèƒ½åˆ›å»ºæ’å…¥ç”µå­é‚®ä»¶çš„æ¶ˆæ¯ã€‚ç”¨ä¼ ç»Ÿçš„å•å…ƒæµ‹è¯•æ–¹æ³•æ¥æµ‹è¯•æ˜¯ç›¸å¯¹å®¹æ˜“çš„...

```
(ns  pbtic.birthday.mail-tpl-test  (:require  [clojure.string  :as  str]  [clojure.test.check.clojure-test  :refer  [defspec]]  [clojure.test.check.generators  :as  gen]  [clojure.test.check.properties  :refer  [for-all]]  [pbtic.birthday.csv-test  :as  csv-test]  [pbtic.birthday.mail-tpl  :as  mail-tpl])  (:import  [java.time  LocalDate]))  ;;;;;;;;;;;;;  ;; generators  (def  date  (gen/let  [days-to-add  gen/nat]  (.plusDays  (LocalDate/of  1900  1  1)  days-to-add)))  (def  employee-map  (gen/let  [vs  (gen/tuple  (gen/not-empty  csv-test/field)  (gen/not-empty  csv-test/field)  date  (gen/not-empty  csv-test/field))]  (zipmap  [:last-name  :first-name  :date-of-birth  :email]  vs)))  ;;;;;;;;;;;;;  ;; properties  (defspec  email-template-has-first-name  (for-all  [employee  employee-map]  (str/includes?  (mail-tpl/body  employee)  (:first-name  employee)))) 
```

å®ç°å¾ˆç®€å•:

```
(ns  pbtic.birthday.mail-tpl)  (defn  body  [{:keys  [first-name]}]  (format  "Happy birthday, dear %s!"  first-name))  (defn  full  [{:keys  [email]  :as  employee}]  [email,  "Happy birthday!",  (body  employee)]) 
```

### [](#plumbing-it-all-together)æŠŠæ‰€æœ‰ä¸œè¥¿éƒ½è£…åœ¨ä¸€èµ·

å‡½æ•°å°†æ‰€æœ‰è¿™äº›æ†ç»‘åœ¨ä¸€èµ·(æ²¡æœ‰ç¼–å†™ä»»ä½•é›†æˆæµ‹è¯•)ã€‚

```
(ns  pbtic.birthday  (:require  [pbtic.birthday.csv  :as  csv]  [pbtic.birthday.employee  :as  employee]  [pbtic.birthday.mail-tpl  :as  mail-tpl])  (:import  [java.time  LocalDate]))  ;;;;;;;;;  ;; helper  (defn-  send-email  [[to,  _topic,  _body]]  (println  "sent birthday email to"  to))  ;;;;;;;;;;;;;  ;; public api  (defn  run  [path  &  {:keys  [curr-date]  :or  {curr-date  (LocalDate/now)}}]  (doseq  [employee  (->>  (slurp  path)  employee/from-csv  (employee/filter-birthday  curr-date))]  (send-email  (mail-tpl/full  employee)))) 
```

ä¸ºäº†æµ‹è¯•å®ƒï¼Œä¼ é€’é›‡å‘˜è®°å½• CSV çš„æ–‡ä»¶åå’Œå¯é€‰çš„â€œå½“å‰æ—¥æœŸâ€(é»˜è®¤ä¸ºä»Šå¤©)ã€‚ä¾‹å¦‚ï¼Œåœ¨ Clojure REPL è¿è¡Œä»¥ä¸‹å‘½ä»¤:

```
user=> (require '[pbtic.birthday :as bday])
user=> (import '[java.time LocalDate])
user=> (bday/run "resources/birthday/employees.csv" :curr-date (LocalDate/of 2019 8 10))
sent birthday email to john.doe@foobar.com
nil 
```

## [](#summary)æ€»ç»“

å°†ä»£ç ä» Erlang/Elixir ç§»æ¤åˆ° Clojure æ˜¯ä¸€ä»¶éå¸¸æ¿€åŠ¨äººå¿ƒçš„äº‹æƒ…ã€‚åœ¨ä¸‹ä¸€ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘å°†ä»‹ç»ä»ç¬¬ 6 ç« â€œå±æ€§é©±åŠ¨çš„å¼€å‘â€ç§»æ¤è¿‡æ¥çš„ä»£ç 

*æœ¬å¸–[åŸºäºå±æ€§çš„æµ‹è¯•:ä» Erlang/Elixir åˆ° Clojure](https://shaolang.github.io/posts/2019-08-10-property-based-testing-from-elixir-to-clojure/) æœ€å…ˆå‡ºç°åœ¨[ä¸Šä¸€ç‚¹ä¸€ç‚¹çš„](https://shaolang.github.io)T5ã€‘*