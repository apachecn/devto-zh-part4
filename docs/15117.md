# è‡ªåˆ¶ React é’©å­:useAsyncEffect æˆ–å¦‚ä½•ç”¨ useEffect å¤„ç†å¼‚æ­¥æ“ä½œ

> åŸæ–‡:[https://dev . to/n1ru 4l/home brew-react-hooks-useasync effect-or-how-to-handle-async-operations-with-use effect-1fa 8](https://dev.to/n1ru4l/homebrew-react-hooks-useasynceffect-or-how-to-handle-async-operations-with-useeffect-1fa8)

# [](#tldr)TLDR

å¼‚æ­¥å‡½æ•°ç¼ºä¹å¯å–æ¶ˆæ€§ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç”Ÿæˆå™¨å‡½æ•°æ¥æ¨¡ä»¿å¯å–æ¶ˆçš„å¼‚æ­¥å‡½æ•°ã€‚æˆ‘ä¸ºç¼–å†™å¼‚æ­¥æ•ˆæœåˆ›å»ºäº†ä¸€ä¸ªåº“: [`useAsyncEffect on Github`](https://github.com/n1ru4l/use-async-effect)

# [](#the-problem)é—®é¢˜

æˆ‘ä»¬å¤§å¤šæ•°äººå–œæ¬¢ä½¿ç”¨ async-await è¯­æ³•ï¼

ä½ ä»¬ä¸­çš„ä¸€äº›äºº(åŒ…æ‹¬æˆ‘)å¯èƒ½å°è¯•è¿‡æ‰§è¡Œä¸‹é¢è¿™æ®µä»£ç 

```
import { useState, useEffect } from "react";

const [state, setState] = useState()
// do not try this at home
useEffect(async () => {
  const data = await fetchSomeData()
  setState(data);
}, []); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

è¿™æ ·åšçš„äººå¯èƒ½è¿˜æ³¨æ„åˆ°è¿™æ®µä»£ç ä¼šåœ¨å¼€å‘äººå‘˜æ§åˆ¶å°ä¸­æ‰“å°ä¸€æ¡å¾ˆå¤§çš„é”™è¯¯æ¶ˆæ¯:

```
Warning: An Effect function must not return anything besides a function, which is used for clean-up.

It looks like you wrote useEffect(async () => ...) or returned a Promise. Instead, you may write an async function separately and then call it from inside the effect:

async function fetchComment(commentId) {
  // You can await here
}

useEffect(() => {
  fetchComment(commentId);
}, [commentId]);

In the future, React will provide a more idiomatic solution for data fetching that doesn't involve writing effects manually. 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

# [](#why-does-raw-useeffect-endraw-not-accept-my-async-functions)ä¸ºä»€ä¹ˆ`useEffect`ä¸æ¥å—æˆ‘çš„å¼‚æ­¥å‡½æ•°ï¼Ÿ

é”™è¯¯æ¶ˆæ¯å®é™…ä¸Šç»™å‡ºäº†æ¸…æ¥šçš„è§£é‡ŠğŸ˜…ã€‚æˆ‘ä»¬æ¥åˆ†è§£ä¸€ä¸‹ï¼

1.  å¼‚æ­¥å‡½æ•°æ€»æ˜¯è¿”å›ä¸€ä¸ª`Promise`ï¼Œå› æ­¤ä½ ä¸èƒ½åŒæ­¥è¿”å›ä¸€ä¸ªæ¸…ç†å‡½æ•°ã€‚

2.  å½“`useEffect`çš„ä¸€ä¸ªä¾èµ–å…³ç³»æ”¹å˜æˆ–è€…ç»„ä»¶å¸è½½æ—¶ï¼ŒReact è°ƒç”¨æ¸…ç†å‡½æ•°ã€‚

å³ä½¿`useEffect`æ”¯æŒè§£å†³æ‰¿è¯ºä¸­çš„æ¸…ç†åŠŸèƒ½ï¼Œè¿™ç§å˜åŒ–ä¹Ÿå¯èƒ½åœ¨`Promise`è§£å†³(æˆ–è€…æ›´ç³Ÿï¼Œè¢«æ‹’ç»)ä¹‹å‰å‘ç”Ÿã€‚ç»“æœï¼Œæ¸…ç†å‡½æ•°è¦ä¹ˆè°ƒç”¨å¾—å¤ªæ™šï¼Œè¦ä¹ˆæ°¸è¿œä¸ä¼šè¢«è°ƒç”¨ã€‚

## ä¸ºä»€ä¹ˆæˆ‘ç”šè‡³éœ€è¦ä¸€ä¸ªæ¸…ç†åŠŸèƒ½ï¼Ÿ

> ![Dan Abramov profile image](../Images/17c386e6839df2dd490f297a2c139b1e.png)ä¸¹é˜¿å¸ƒæ‹‰è«å¤«[@ä¸¹ _ é˜¿å¸ƒæ‹‰è«å¤«](https://dev.to/dan_abramov)![twitter logo](../Images/65e26e35707d96169ec8af6b3cbf2003.png)æœ‰æ²¡æœ‰æƒ³è¿‡ä¸ºä»€ä¹ˆä¸èƒ½æŠŠå¼‚æ­¥å‡½æ•°ç›´æ¥ä½œä¸º useEffect å®å‚ï¼Œè€Œéè¦æ”¾åœ¨é‡Œé¢ï¼Ÿè¿™ä¸æ˜¯æŠ€æœ¯ä¸Šçš„é™åˆ¶ã€‚å®ƒæœ‰åŠ©äºå¼•å¯¼æ‚¨æ‰¾åˆ°èƒ½å¤Ÿå¾ˆå¥½åœ°å¤„ç†ç«äº‰æ¡ä»¶çš„ä»£ç ã€‚[twitter.com/dan_abramov/stâ€¦](https://t.co/Y94AxDCGcu)20:32PM-04 2019 å¹´ 7 æœˆä¸¹Â·é˜¿å¸ƒæ‹‰è«å¤«[@ä¸¹ _ é˜¿å¸ƒæ‹‰è«å¤«](https://dev.to/dan_abramov)[@ thepaulcbride](https://dev.to/thepaulmcbride)[@ chrislaughlin](https://dev.to/chrislaughlin)è™½ç„¶æœ‰å……åˆ†çš„ç†ç”±ï¼Œå¦‚æœæ‚¨çš„æ•ˆæœå‡½æ•°æ˜¯â€œå¼‚æ­¥â€çš„ï¼Œé‚£ä¹ˆæ‚¨å°±æ²¡æœ‰æœºä¼šå¿½ç•¥é™ˆæ—§çš„è·å–ç»“æœ(æˆ–è€…å–æ¶ˆè·å–)ğŸ™‚https://t.co/N8SE6BkbmC[![Twitter reply action](../Images/5d5a32424597af8488f7190c7d7d496b.png)](https://twitter.com/intent/tweet?in_reply_to=1146879490347470848)[![Twitter retweet action](../Images/3d12d4a909b79beaf8d81b6491fd052d.png)](https://twitter.com/intent/retweet?tweet_id=1146879490347470848)[![Twitter like action](../Images/3f89df2f36e8e5624d2a25952b3ac8b8.png)](https://twitter.com/intent/like?tweet_id=1146879490347470848)

ç»™å®šè¿™ä¸ªæœ‰æ•ˆçš„ react `useEffect`ç”¨æ³•:

```
const [data, setData] = useState();
useEffect(() => {
  const runEffect = async () => {
    const data = await fetchSomeData(filter);
    setData(data);
  };
  runEffect();
}, [setData, filter]); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

è®©æˆ‘ä»¬å‡è®¾ç»„ä»¶åœ¨`fetchSomeData`æ‰¿è¯ºä»æœªè§£å†³æ—¶å¸è½½ã€‚è¿™æ„å‘³ç€å°½ç®¡ç»„ä»¶å·²ç»è¢«å¸è½½ï¼Œä½†ä»è°ƒç”¨äº†`setData`ã€‚

ä½ å¯èƒ½è¿˜è®°å¾—æ¥è‡ªç±»ç»„ä»¶çš„`Can't call setState (or forceUpdate) on an unmounted component.`è­¦å‘Šï¼Œè¿™ä»ç„¶é€‚ç”¨äºé’©å­ã€‚

æ›´ç³Ÿç³•çš„æ˜¯ï¼Œå½“è¿‡æ»¤å™¨ä¾èµ–æ€§åœ¨`fetchSomeData`è§£å†³ä¹‹å‰æ”¹å˜æ—¶ï¼Œæˆ‘ä»¬æœ‰ä¸¤ä¸ªç«äº‰æ¡ä»¶å†²çªã€‚å¦‚æœç”±äºæŸç§åŸå› ï¼Œç¬¬äºŒä¸ª`fetchSomeData`æ‰¿è¯ºåœ¨ç¬¬ä¸€ä¸ª`fetchSomeData`æ‰¿è¯ºä¹‹å‰è§£å†³äº†å‘¢ï¼Ÿåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä¸€æ—¦å»¶è¿Ÿçš„æ‰¿è¯ºå¾—åˆ°è§£å†³,â€œæ–°â€æ•°æ®å°†è¢«â€œæ—§â€æ•°æ®è¦†ç›–ğŸ˜²ã€‚

æˆ‘ä»¬ç©¶ç«Ÿå¦‚ä½•é˜²æ­¢è¿™ç±»é—®é¢˜ï¼Ÿ

## [](#asyncawait-is-not-perfect)å¼‚æ­¥-Await å¹¶ä¸å®Œç¾

åœ¨ç†æƒ³çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¸å¿…å…³å¿ƒè¿™äº›äº‹æƒ…ï¼Œä½†ä¸å¹¸çš„æ˜¯ï¼Œå–æ¶ˆå¼‚æ­¥å‡½æ•°æ˜¯ä¸å¯èƒ½çš„ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å¿…é¡»åœ¨æ¯æ¬¡å¼‚æ­¥æ“ä½œ(`Promise`)åæ£€æŸ¥å½“å‰çš„`useEffect`å‘¨æœŸæ˜¯å¦å·²ç»ç»“æŸã€‚

```
const [data, setData] = useState();
useEffect(() => {
  let cancel = false;
  const runEffect = async () => {
    const data = await fetchSomeData(filter);
    if (cancel) {
      return;
    }
    setData(data);
  };
  runEffect();

  // Cleanup function that will be called on
  // 1\. Unmount
  // 2\. Dependency Array Change
  return () => {
    cancel = true;
  }
}, [setData, filter]); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

åœ¨ä¸€ä¸ªå¼‚æ­¥å‡½æ•°ä¸­ï¼Œè¿™å¯èƒ½ä¼šå˜å¾—éå¸¸ä¹å‘³ï¼Œå› ä¸ºå®ƒä¼šä¾æ¬¡æ‰§è¡Œè®¸å¤šç­‰å¾…:

```
const [data1, setData1] = useState();
const [data2, setData2] = useState();
const [data3, setData3] = useState();
useEffect(() => {
  let cancel = false;

  const runEffect = async () => {
    const data1 = await fetchSomeData(filter);
    if (cancel) {
      return;
    }
    setData1(data);

    const data2 = await fetch(data1.url);
    if (cancel) {
      return;
    }
    setData2(data);

    const data3 = await fetch(data2.url);
    if (cancel) {
      return;
    }
    setData3(data);
  };
  runEffect();

  // Cleanup function that will be called on
  // 1\. Unmount
  // 2\. Dependency Array Change
  return () => {
    cancel = true;
  }
}, [setData1, setData2, setData3, filter]); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

è¿™æ˜¯æˆ‘ä»¬å¯ä»¥ç¡®ä¿åœ¨è°ƒç”¨æ¸…ç†å‡½æ•°åä¸è°ƒç”¨`setState`çš„å”¯ä¸€æ–¹æ³•ï¼Œå°½ç®¡å¦‚æ­¤ï¼Œå¼‚æ­¥æ“ä½œä¹Ÿå°±æ˜¯ç½‘ç»œè¯·æ±‚(é€šè¿‡`fetch`å‘èµ·)ä»åœ¨æ‰§è¡Œã€‚

# [](#cancelling-pending-async-operations)å–æ¶ˆæŒ‚èµ·çš„å¼‚æ­¥æ“ä½œ

ç°ä»£æµè§ˆå™¨é™„å¸¦äº†ä¸€ä¸ªåä¸º`AbortController`çš„æ–° APIï¼Œå¯ä»¥ç”¨æ¥ä¸­æ­¢æœªå†³çš„`fetch`è¯·æ±‚ã€‚

```
const [data, setData] = useState();
useEffect(() => {
  const controller = new AbortController();
  const runEffect = async () => {
    try {
      const data = await fetch(
        "https://foo.bars/api?filter=" + filter,
        { signal: controller.signal }
      );
      setData(data);
    } catch (err) {
      if (err.name === 'AbortError') {
        console.log("Request was canceled via controller.abort");
        return;
      }
      // handle other errors here
    }
  };
  runEffect();

  return () => {
    controller.abort();
  }
}, [setData, filter]); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

ç°åœ¨ï¼Œæ¯å½“è¿‡æ»¤å™¨æ”¹å˜æˆ–ç»„ä»¶æ›´æ–°æ—¶ï¼ŒæŒ‚èµ·çš„ç½‘ç»œè¯·æ±‚è¢«ä¸­æ­¢ã€‚å–æ•°æ®`Promise`å°†æ‹’ç»ï¼Œè€Œä¸æ˜¯è§£æï¼Œå¹¶å‡ºç°é”™è¯¯ğŸ‘Œã€‚

ä½ å¯ä»¥åœ¨è¿™é‡Œäº†è§£æµè§ˆå™¨å¯¹`AbortController`çš„æ”¯æŒ(å½“ç„¶ IE ä¸æ”¯æŒ`AbortController`ğŸ˜–):ã€https://caniuse.com/#feat=abortcontroller T2ã€‘

[æœ‰ä¸€ä¸ªå¤šå¡«å……ç‰©å¯ç”¨](https://www.npmjs.com/package/abortcontroller-polyfill)ã€‚å®ƒå®é™…ä¸Šå¹¶ä¸å®ç°å–æ¶ˆï¼Œå› ä¸ºå®ƒå¿…é¡»åœ¨æµè§ˆå™¨ä¸­æœ¬åœ°å®Œæˆã€‚ç›¸åï¼Œå®ƒé€šè¿‡åœ¨ fetch è°ƒç”¨è¢«è§£æ/æ‹’ç»åæŠ›å‡ºä¸­æ­¢é”™è¯¯æ¥æ¨¡æ‹Ÿè¡Œä¸ºã€‚

æ­¤å¤–ï¼Œè¿™ä¸ªè§£å†³æ–¹æ¡ˆåªé€‚ç”¨äº fetch è°ƒç”¨ğŸ˜•ã€‚æœ‰äº› API æä¾›äº†å–æ¶ˆå¼‚æ­¥æ“ä½œçš„æ–¹æ³•ï¼Œæœ‰äº›åˆ™æ²¡æœ‰ã€‚

ä¾‹å¦‚ï¼Œè¿™å°±æ˜¯ä»Šå¤©ä½ å¦‚ä½•å–æ¶ˆç”¨`useEffect`é’©å­åŠ è½½`Image`:

```
export const loadImage = src => {
  const image = new Image();
  const done = false;

  const cancel = () => {
    if (done) {
      // do not change the image instance once it has been loaded
      return;
    }
    // this will abort the request and trigger the error event
    image.src = "";
  };

  const promise = new Promise((resolve, reject) => {
    image.src = src;
    const removeEventListeners = () => {
      image.removeEventListener("load", loadListener);
      image.removeEventListener("error", errorListener);
    };
    const loadListener = () => {
      removeEventListeners();
      done = true;
      resolve(image);
    };
    const errorListener = err => {
      removeEventListeners();
      reject(err);
    };
    image.addEventListener("load", loadListener);
    image.addEventListener("error", errorListener);
  });

  return { promise, cancel };
};

useEffect(() => {
  const task = loadImage(url)
  const runEffect = async () => {
    try {
      const image = await task.promise;
      // do sth with image
    } catch (err) {
      // handle cancel error
    }

  };
  runEffect();

  return () => {
    task.cancel();
  }
}, [url]) 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

åœ¨ä½¿ç”¨å…¶ä»–ä¸å¯æ’¤é”€çš„å¼‚æ­¥ API çš„ç¯å¢ƒä¸­ï¼Œæ‚¨ä»ç„¶éœ€è¦è®¾ç½®å’Œæ£€æŸ¥ä¸€ä¸ªå¸ƒå°”å˜é‡ã€‚

å¸Œæœ›æœ‰ä¸€å¤©æ‰€æœ‰åŸºäºå¼‚æ­¥çš„ API éƒ½æ”¯æŒä½¿ç”¨`AbortController`ã€‚

ç°åœ¨ï¼Œæˆ‘ä»¬å¿…é¡»å¤„ç†å¸ƒå°”æ£€æŸ¥å’Œå°è¯•æ•æ‰çš„æ··åˆã€‚

ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬å¯ä»¥å¯¹å–æ¶ˆè¯·æ±‚å’Œåœ¨ä¸€ä¸ª`await`å…³é”®å­—ååœæ­¢å‡½æ•°æ‰§è¡Œè¿›è¡Œä¸€äº›æŠ½è±¡ï¼Œé‚£ä¼šæ€ä¹ˆæ ·å‘¢ï¼Ÿ

# [](#introducing-raw-useasynceffect-endraw-)ä»‹ç»`useAsyncEffect`

ä½ ä»¥å‰å¬è¯´è¿‡ç”Ÿæˆå™¨å‡½æ•°å—ï¼Ÿ

```
const generator = function *() {
  yield "bars";
  yield "foo";
  return "fizz"
} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

ç”Ÿæˆå‡½æ•°æ˜¯ä¸€ä¸ªå¯æš‚åœå‡½æ•°ã€‚`yield`å…³é”®å­—è¡¨ç¤ºåŠŸèƒ½æš‚åœã€‚è®©æˆ‘ä»¬è¿è¡Œè¿™ä¸ªå‘ç”µæœºï¼

```
// create instance of generator
const instance = generator();
// call next to run the generator until the next yield keyword
let result = instance.next();
console.log(result); // {value: "bars", done: false}
// continue calling
result = instance.next();
console.log(result); // {value: "foo", done: false}
// we can continue calling next until done is true
result = instance.next();
console.log(result); // {value: "fizz", done: true} 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

é™¤äº†å°†å€¼ä»ç”Ÿæˆå™¨ä¸­ä¼ é€’å‡ºå»ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥å°†å€¼ä½œä¸º`next`æ–¹æ³•çš„å‚æ•°ä¼ é€’è¿›æ¥:

```
const generator = function *() {
  const echo = yield "hello";
  console.log(echo);
}

// create instance of generator
const instance = generator();
let result = instance.next();
console.log(result); // {value: "hello", done: false}
// pass string into generator that will be assigned to the echo variable
instance.next("hello generator"); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

è¿™å¤ªé…·äº†ï¼ä½†æ˜¯è¿™å¦‚ä½•å¸®åŠ©æˆ‘ä»¬è§£å†³å¼‚æ­¥ç­‰å¾…é—®é¢˜å‘¢ï¼Ÿ

## è¿‡å»ï¼Œç”Ÿæˆå™¨è¢«ç”¨æ¥æ¨¡æ‹Ÿå¼‚æ­¥ç­‰å¾…è¡Œä¸º

è‡ª [ECMAScript 2015(ç¬¬å…­ç‰ˆï¼ŒECMA-262)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function*#Specifications) ä»¥æ¥ï¼Œå‘ç”µæœºå°±ä¸€ç›´å­˜åœ¨

ç›´åˆ° [ECMAScript 2017 (ECMA-262)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function#Specifications) ï¼Œå¼‚æ­¥å‡½æ•°æ‰æˆä¸ºè§„èŒƒçš„ä¸€éƒ¨åˆ†

åœ¨ EcmaScript 2015 å¹´åˆ° 2017 å¹´æœŸé—´ï¼Œå‡ºç°äº†å„ç§ç”¨ç”Ÿæˆå™¨æ¨¡ä»¿ async-await è¡Œä¸ºçš„åº“ã€‚

å…¶ä¸­æœ€å—æ¬¢è¿çš„æ˜¯ [`co`](https://www.npmjs.com/package/co)

```
import co from 'co';

// wrap generator into function that returns a promise
const asyncFunction = co.wrap(function * () {
  const result = yield fetch(url);
  console.log(result);
  return 1
});

asyncFunction().then((res) => {
  assert.equal(res, 1);
}) 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

`Co`åŸºæœ¬ä¸Šè¿è¡Œå‘ç”µæœºï¼Œç›´åˆ°æ‰¿è¯ºè¢«`yield` -edï¼Œç„¶åç­‰å¾…æ‰¿è¯ºè§£æï¼Œå¹¶ç»§ç»­ä»¥è§£æçš„æ‰¿è¯ºå€¼(`get.next(resolvedPromiseValue)`)è¿è¡Œå‘ç”µæœºï¼Œç›´åˆ°å‘ç”µæœºå®Œæˆ(`gen.next(resolvedPromiseValue).done === true`)ã€‚

åŒºåˆ† async-await å’Œ generators çš„ä¸€ç‚¹(é™¤äº†å®ƒä»¬çš„è¯­æ³•)æ˜¯ï¼Œåœ¨æš‚åœäº†ä¹‹åï¼Œ**ç”Ÿæˆå™¨ä¸ä¼šè¢«å¼ºåˆ¶è§£æ`Promise`æˆ–è€…ç”šè‡³ç»§ç»­æ‰§è¡Œç”Ÿæˆå™¨å‡½æ•°ã€‚**

è¿™åŸºæœ¬ä¸Šæ„å‘³ç€æˆ‘ä»¬å¯ä»¥å°†ç”Ÿæˆå™¨ç”¨ä½œâ€œå¯å–æ¶ˆçš„â€å¼‚æ­¥ç­‰å¾…ã€‚

## [](#lets-built-that-raw-useasynceffect-endraw-hook)å’±ä»¬å»ºé‚£ä¸ª`useAsyncEffect`é’©å­

### [](#implementation)å®ç°

```
import { useEffect } from "react";

const noop = () => {}

const useAsyncEffect = (generator, deps = []) => {
  // store latest generator reference
  const generatorRef = useRef(generator);
  generatorRef.current = generator;

  useEffect(() => {
    let ignore = false;
    let onCancel = noop;

    const runGenerator = async () => {
      // create generator instance
      const instance = generatorRef.current(_onCancel => {
        // allow specifying a onCancel handler
        // that can be used for aborting async operations
        // e.g. with AbortController
        // or simple side effects like logging
        // For usage: see example below
        onCancel = _onCancel || noop;
      });

      // generator result
      let res = { value: undefined, done: false };
      do {
        res = instance.next(res.value);
        try {
          // resolve promise
          res.value = await res.value;
        } catch (err) {
          try {
            // generator also allow triggering a throw
            // instance.throw will throw if there is no
            // try/catch block inside the generator function
            res = instance.throw(err);
          } catch (err) {
            // in case there is no try catch around the yield
            // inside the generator function
            // we propagate the error to the console
            console.error("Unhandeled Error in useAsyncEffect: ", err);
          }
        }

        // abort further generator invocation on
        // 1\. Unmount
        // 2\. Dependency Array Change
        if (ignore) {
          return;
        }
      } while (res.done === false);
    };
    runGenerator();

    // Cleanup function that will be called on
    // 1\. Unmount
    // 2\. Dependency Array Change
    return () => {
      ignore = true;
      onCancel();
    };
  }, deps);
}; 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

### [](#usage)ç”¨æ³•

```
const [data, setData] = useState();
useAsyncEffect(function * (onCancel) {
  const controller = new AbortController();

  // handle error 
  onCancel(() => {
    console.log("cancel while fetch is still executed, use controller for aborting the request.");
    controller.abort();
  });
  try {
    const data = yield fetch(
      "https://foo.bars/api?filter=" + filter,
      { signal: controller.signal }
    )
    setData(data);
  } catch (err) {
    if (err.name === 'AbortError') {
      console.log("Request was canceled via controller.abort")
      // we know that an 'AbortError' occurs when the request is
      // cancelled this means that the next promise returned by yield
      // will be created but not actively used, thus, we return in
      // order to avoid the promise being created.
      return;
    }
  }

  // set new cancel handler
  onCancel(() => {
    console.log("cancel while doSthAsyncThatIsNotCancelable is still being executed");
  });
  const newData = yield doSthAsyncThatIsNotCancelable();
  setData(newData);

  // all our async operations have finished
  // we do not need to react to anything on unmount/dependency change anymore
  onCancel(() => {
    console.log("everything ok");
  })
}, [setData, filter]); 
```

<svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title></svg> <svg width="20px" height="20px" viewBox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title></svg>

è¿™ä¸ªé’©å­ç°åœ¨å…è®¸æˆ‘ä»¬çœç•¥ç»„ä»¶ä¸­æ‰€æœ‰çš„å¸ƒå°”æ£€æŸ¥(`ignore === true`)ï¼ŒåŒæ—¶ä»ç„¶ç»™æˆ‘ä»¬å–æ¶ˆå¼‚æ­¥æ“ä½œ(å¯å–æ¶ˆçš„)çš„æƒåŠ›ï¼Œæˆ–è€…é€šè¿‡å‘`onCancel`æ³¨å†Œä¸€ä¸ªå¤„ç†å‡½æ•°æ¥å¤„ç†å…¶ä»–å‰¯ä½œç”¨ã€‚

æˆ‘å¸Œæœ›ä½ å–œæ¬¢è¯»è¿™ç¯‡æ–‡ç« ï¼

ä½ ä»¥å‰ç”¨è¿‡å‘ç”µæœºå—ï¼Ÿä»Šå¤©ä½ å¦‚ä½•å¤„ç†ä¸`useEffect`çš„å¼‚æ­¥æ“ä½œï¼Ÿä½ ä¼šåœ¨ä»£ç ä¸­ä½¿ç”¨`useAsyncEffect`é’©å­å—ï¼Ÿä½ æœ‰ä»»ä½•åé¦ˆæˆ–å‘ç°äº†ä¸€ä¸ªé”™è¯¯å—ï¼Ÿ

å¤§å®¶åœ¨è¯„è®ºé‡Œè®¨è®ºå§ï¼

æ­¤å¤–ï¼Œè¯·åœ¨è¿™äº›å¹³å°ä¸Šéšæ—¶å…³æ³¨æˆ‘ï¼Œå¦‚æœä½ å–œæ¬¢è¿™ç¯‡æ–‡ç« ï¼Œæˆ‘ä¿è¯ä½ ä¼šçœ‹åˆ°æ›´å¤šç²¾å½©çš„å†…å®¹ã€‚æˆ‘å†™çš„æ˜¯ JavaScriptã€Nodeã€React å’Œ GraphQLã€‚

*   [å¼€å‘åˆ°](https://dev.to/n1ru4l)
*   [ä¸­ç­‰](https://medium.com/@n1ru4l)
*   [æ¨ç‰¹](https://twitter.com/n1rual)
*   [Github](https://github.com/n1ru4l)

ç¥ä½ æœ‰ä¸€ä¸ªç¾å¥½è€Œå¯Œæœ‰æˆæ•ˆçš„ä¸€å¤©ï¼