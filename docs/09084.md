# é€šè¿‡ MongoDB æœåŠ¡å™¨ä¼šè¯ä½¿ç”¨ NestJS åœ¨ GraphQL API ä¸­å®ç°å› æœä¸€è‡´æ€§

> åŸæ–‡:[https://dev . to/Nicky lenaers/achieving-causal-consistency-in-your-graph QL-API-using-nestjs-with-MongoDB-server-sessions-3g O1](https://dev.to/nickylenaers/achieving-causal-consistency-in-your-graphql-api-using-nestjs-with-mongodb-server-sessions-3go1)

*â€œç°åœ¨å®ç°ä»€ä¹ˆäº†ï¼Ÿ!"*

åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬å°†å…³æ³¨å¦‚ä½•å®ç°**å› æœä¸€è‡´æ€§**ï¼Œè¿™æ˜¯ä¸€ä¸ªæ•æ‰è½¯ä»¶ç³»ç»Ÿä¸­æ“ä½œä¹‹é—´å› æœå…³ç³»çš„æ¦‚å¿µã€‚æˆ‘ä»¬å°†é€šè¿‡æŸ¥çœ‹å¸¦æœ‰ [GraphQL](https://graphql.org/) ç«¯ç‚¹çš„[èŠ‚ç‚¹](https://nodejs.org) API çš„ä»£ç ç¤ºä¾‹æ¥åšåˆ°è¿™ä¸€ç‚¹ã€‚æˆ‘ä»¬å°†ä½¿ç”¨ [NestJS](https://nestjs.com/) ä½œä¸ºæˆ‘ä»¬çš„ API æ¡†æ¶ï¼Œä½¿ç”¨[mongose](https://mongoosejs.com/)ä½œä¸ºæˆ‘ä»¬çš„ MongoDB é€‚é…å™¨ã€‚åœ¨æœ¬æ–‡ç»“æŸæ—¶ï¼Œæ‚¨å°†:

*   ç†Ÿæ‚‰å› æœä¸€è‡´æ€§çš„æ¦‚å¿µ
*   èƒ½å¤Ÿè®¤è¯†åˆ°å› æœä¸€è‡´æ€§çš„å¿…è¦æ€§
*   èƒ½å¤Ÿä½¿ç”¨ç°ä»£æŠ€æœ¯å †æ ˆæ„å»ºèŠ‚ç‚¹å®ç°

# [](#causal-consistency)å› æœä¸€è‡´æ€§

**å› æœä¸€è‡´æ€§**çš„æ¦‚å¿µæŠ“ä½äº†æ“ä½œä¹‹é—´çš„å› æœå…³ç³»ã€‚è¿™æ„å‘³ç€ï¼Œå¦‚æœæˆ‘ä»¬æœ‰ä¸€äº›æ“ä½œ`A`å¯¼è‡´*æ“ä½œ*æ“ä½œ`B`ï¼Œå› æœä¸€è‡´æ€§æä¾›äº†æ“ä½œé¡ºåºçš„ä¿è¯ï¼Œè€Œä¸ç®¡å®ƒä»¬è¿è¡Œåœ¨å½“å‰çš„è¿›ç¨‹ä¸­ã€‚å¦‚æœæˆ‘ä»¬ä¸å°†è¿™ç§ä¿è¯è½å®åˆ°ä½ï¼Œæµç¨‹å¯èƒ½æ— æ³•å°±æ‰§è¡Œé¡ºåºè¾¾æˆä¸€è‡´ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯èƒ½æœ‰ä¸€ä¸ªåœ¨æ–¹`A`å’Œæ–¹`B`ä¹‹é—´è½¬è´¦çš„åº”ç”¨ç¨‹åºï¼Œè½¬è´¦ä»`A`åˆ°`B`ã€‚æ±‡æ¬¾ç”±ä¸¤éƒ¨åˆ†ç»„æˆ:

1.  ä»é“¶è¡Œè´¦æˆ·å–é’±`A`
2.  å°†é’±å­˜å…¥é“¶è¡Œè´¦æˆ·`B`

é™¤äº†è¿™äº›æ­¥éª¤çš„é¡ºåºä¹‹å¤–ï¼Œé‡è¦çš„æ˜¯ï¼Œå¦‚æœè¿™äº›æ“ä½œä¸­çš„ä»»ä½•ä¸€ä¸ªå¤±è´¥ï¼Œåˆ™å¦ä¸€ä¸ªåº”è¯¥æ— æ•ˆã€‚ä¾‹å¦‚ï¼Œå‡è®¾åªæœ‰æ­¥éª¤ 1 æˆåŠŸã€‚ç„¶åæˆ‘ä»¬ä»`A`å¤„å–é’±ï¼Œä½†`B`ä»æœªæ”¶åˆ°ï¼Œåä¹‹äº¦ç„¶ã€‚

åœ¨æ¥ä¸‹æ¥çš„å‡ èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†çœ‹ä¸€ä¸ªç”±ä¸€ç»„éœ€æ±‚å®šä¹‰çš„ç®€å•ç”¨ä¾‹ï¼Œä»¥åŠä¸€äº›ç”¨äºå®ç°å› æœä¸€è‡´æ€§çš„æŠ€æœ¯ã€‚

# [](#use-case)ğŸ•ç”¨ä¾‹

å‡ºäºæ¼”ç¤ºçš„ç›®çš„ï¼Œæˆ‘ä»¬é‡‡ç”¨ä¸€ä¸ªç®€å•çš„ pizza delivery èŠ‚ç‚¹ APIï¼Œå®ƒæœ‰ä¸€ä¸ªåä¸º`orderPizza`çš„ GraphQL ç«¯ç‚¹ã€‚å‰ç«¯ web åº”ç”¨ç¨‹åºä½¿ç”¨è¯¥ç«¯ç‚¹æ¥è®¢è´­æ¯”è¨é¥¼ã€‚ä¸€æ—¦ç”¨æˆ·ç‚¹å‡»äº†ç«¯ç‚¹ï¼ŒAPI è¦æ±‚å£°æ˜åº”è¯¥å‘ç”Ÿä¸¤ä»¶äº‹æƒ…:

1.  åœ¨`pizza-orders`é›†åˆä¸­åˆ›å»ºæ–°çš„è®¢å•æ–‡æ¡£ã€‚
2.  åœ¨`users`é›†åˆä¸­æ·»åŠ å¯¹è¯·æ±‚ç”¨æˆ·æ–‡æ¡£çš„è®¢å•å¼•ç”¨ã€‚

    åè€…å°†ç”¨äºé«˜æ•ˆæŸ¥è¯¢æ¯ä¸ªç”¨æˆ·çš„è®¢å•ï¼Œå› ä¸ºæˆ‘ä»¬å¸Œæœ›é¿å…æ¯æ¬¡ç”¨æˆ·è¯·æ±‚è‡ªå·±çš„è®¢å•æ—¶æ‰«ææ•´ä¸ª`pizza-orders`é›†åˆã€‚è¿™ä¸ªéœ€æ±‚å¾ˆé‡è¦ï¼Œå› ä¸ºæ½œåœ¨çš„åŠ¨æœºæ­ç¤ºäº†åº”è¯¥åœ¨ API ä¸­å¼ºåˆ¶æ‰§è¡Œçš„æ£€ç´¢æ¯ç”¨æˆ·è®¢å•çš„*æ•°æ®è®¿é—®æ¨¡å¼*ã€‚æ­¤å¤–ï¼Œè¦æ±‚æŒ‡å‡º:

3.  æ“ä½œåº”**å› æœä¸€è‡´**ã€‚æ¢å¥è¯è¯´:æŒ‰é¡ºåºæ‰§è¡Œï¼Œå¦‚æœä¸€ä¸ªæ“ä½œå¤±è´¥ï¼Œå…¶ä»–æ“ä½œåº”è¯¥ä¸­æ­¢ã€‚

æ—¢ç„¶æˆ‘ä»¬å·²ç»å»ºç«‹äº†éœ€æ±‚ï¼Œæˆ‘ä»¬å¯ä»¥å¼€å§‹è€ƒè™‘å®ç°äº†ã€‚

# é›€å·¢å…¬å¸

NestJS æ˜¯æœ€å¥å£®çš„èŠ‚ç‚¹ API æ¡†æ¶ä¹‹ä¸€ã€‚å®ƒæä¾›äº†ä¸€ä¸ªå¼ºå¤§çš„æ¨¡å—åŒ–ç³»ç»Ÿï¼Œä»¥åŠåƒ TypeScript æ”¯æŒå’Œä¾èµ–æ³¨å…¥è¿™æ ·çš„ç‰¹æ€§ï¼Œå°±åƒåœ¨ Angular è¿™æ ·çš„æ¡†æ¶ä¸­çœ‹åˆ°çš„é‚£æ ·ã€‚ä½¿ç”¨ MongoDB çš„å…¸å‹ç°ä»£ API å¯èƒ½ä¼šè¾¾åˆ°è¿™æ ·ä¸€ä¸ªç¨‹åº¦ï¼Œå³éœ€è¦åœ¨ä¸€ä¸ªæ“ä½œä¸­æ›´æ–°*å¤šä¸ªæ–‡æ¡£ï¼Œå°½ç®¡æ•°æ®ç»“æ„å¯èƒ½ä¸æä¾›è¿™æ ·çš„åŸå­æ€§ã€‚ç›¸åï¼Œæ‰§è¡Œå¤šæ–‡æ¡£å†™æ“ä½œçš„æŒ‘æˆ˜å‡ºç°äº†ã€‚å°½ç®¡è¿™äº›æ“ä½œæœ¬èº«éƒ½æ˜¯åŸå­æ€§çš„ï¼Œä½†æ“ä½œä½œä¸ºä¸€ä¸ªæ•´ä½“å´ä¸æ˜¯ã€‚è¿™å¯èƒ½ä¼šå¯¼è‡´æˆ‘ä»¬çš„æ•°æ®æ›´æ–°ä¸ä¸€è‡´ï¼Œå› ä¸ºæˆ‘ä»¬çš„æ•°æ®å¯èƒ½ä¸**æœ‰å› æœå…³ç³»**ã€‚è¿™å°±æ˜¯ [MongoDB æœåŠ¡å™¨ä¼šè¯](https://docs.mongodb.com/manual/reference/method/Session/)çš„ç”¨æ­¦ä¹‹åœ°ã€‚å¹¸è¿çš„æ˜¯ï¼ŒNestJS æä¾›äº†[æ‹¦æˆªå™¨](https://docs.nestjs.com/interceptors)å’Œ[å®šåˆ¶è£…é¥°å™¨](https://docs.nestjs.com/custom-decorators)çš„æ¦‚å¿µï¼Œä»¥ä¸€ç§ç®€æ´çš„æ–¹å¼é›†æˆ MongoDB æœåŠ¡å™¨ä¼šè¯ã€‚*

# [](#mongodb-server-sessions)MongoDB æœåŠ¡å™¨ä¼šè¯

MongoDB æœåŠ¡å™¨ä¼šè¯çš„æ¦‚å¿µä¸ mongose ä¸­çš„ [`Transactions`](https://mongoosejs.com/docs/transactions.html) æœ‰äº›ç±»ä¼¼ï¼Œå› ä¸º mongose äº‹åŠ¡æ˜¯å»ºç«‹åœ¨ MongoDB æœåŠ¡å™¨ä¼šè¯ä¹‹ä¸Šçš„ã€‚æ¥è‡ª[å®˜æ–¹æ–‡ä»¶](https://docs.mongodb.com/manual/reference/server-sessions/):

> MongoDB çš„æœåŠ¡å™¨ä¼šè¯æˆ–é€»è¾‘ä¼šè¯æ˜¯å®¢æˆ·ç«¯ä¼šè¯ç”¨æ¥æ”¯æŒå› æœä¸€è‡´æ€§å’Œå¯é‡è¯•å†™å…¥çš„åº•å±‚æ¡†æ¶ã€‚

è¯·æ³¨æ„ï¼ŒMongoDB æœåŠ¡å™¨ä¼šè¯æœ‰å…¶å±€é™æ€§ã€‚å†æ¬¡æ¥è‡ª[å®˜æ–¹æ–‡ä»¶](https://docs.mongodb.com/manual/reference/server-sessions/):

> *æœåŠ¡å™¨ä¼šè¯ä»…é€‚ç”¨äºå‰¯æœ¬é›†å’Œåˆ†ç‰‡é›†ç¾¤ã€‚*

å¦‚æœåœ¨æœ¬åœ°ç¯å¢ƒä¸­è®¾ç½® MongoDB å‰¯æœ¬é›†æœ‰é—®é¢˜ï¼Œå¯ä»¥ä½¿ç”¨ [MongoDB Atlas](https://www.mongodb.com/cloud/atlas) è®¾ç½®ä¸€ä¸ªå…è´¹çš„ MongoDB é›†ç¾¤ã€‚

# [](#implementation-time)å®ç°æ—¶é—´

## [](#nestjs-mongoose-amp-graphql-setup)NestJS çŒ«é¼¬& GraphQL è®¾ç½®

ä¸ºäº†å®ç°æˆ‘ä»¬çš„ API éœ€æ±‚ï¼Œæˆ‘ä»¬ä»åˆ©ç”¨ [`@nestjs/graphql`](https://www.npmjs.com/package/@nestjs/graphql) æ¨¡å—å¼€å§‹ã€‚å®ƒä¸º GraphQL ç«¯ç‚¹çš„å¿«é€Ÿå®ç°æä¾›äº†ä¸€äº›å¾ˆå¥½çš„æŠ½è±¡ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨å–è‡ª [`@nestjs/mongoose`](https://www.npmjs.com/package/@nestjs/mongoose) çš„`MongooseModule`è¿›è¡Œæ•°æ®åº“äº¤äº’ã€‚æˆ‘ä»¬é¦–å…ˆå°†è¿™äº›æ¨¡å—æ·»åŠ åˆ°æˆ‘ä»¬çš„ä¸»è¦ NestJS åº”ç”¨ç¨‹åºæ¨¡å—ä¸­:

#### **`app.module.ts`T4ã€‘**

```
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';
import { MongooseModule } from '@nestjs/mongoose';

/**
 * You can use your own connection string for connecting
 * to a MongoDB Replica Set using the `forRoot` method of
 * the `MongooseModule`.
 */
@Module({
  imports: [
    MongooseModule.forRoot('mongodb+srv://user:password@cluster/database'),
    GraphQLModule.forRoot()
  ]
})
export class AppModule {} 
```

æŒ‰ç…§ NestJS çš„æ–¹æ³•ï¼Œæˆ‘ä»¬çš„ä¸‹ä¸€ä¸ªç›®æ ‡æ˜¯åˆ›å»ºä¸€ä¸ª`PizzaOrder`æ¨¡å—ï¼Œåœ¨å…¶ä¸­æˆ‘ä»¬å¯ä»¥å®šä¹‰æˆ‘ä»¬çš„ MongoDB `PizzaOrderSchema`ã€GraphQL `PizzaOrderResolver`å’Œ`PizzaOrderService`ã€‚ä½¿ç”¨åŸºäºç‰¹å¾çš„æ–‡ä»¶å’Œæ–‡ä»¶å¤¹ç»“æ„ï¼Œæˆ‘ä»¬éœ€è¦è¿™æ ·çš„ä¸œè¥¿:

```
.
ğŸ“ pizza-order/
  +-- ğŸ“ models/
    +-- pizza-order.model.ts
  +-- ğŸ“ schemas/
    +-- pizza-order.schema.ts
  +-- pizza-order.module.ts
  +-- pizza-order.resolver.ts
  +-- pizza-order.service.ts
+-- app.module.ts 
```

è¿™ç§æ–¹æ³•å¯ä»¥å¾ˆå¥½åœ°åˆ†ç¦»å…³æ³¨ç‚¹ï¼Œå¹¶åœ¨ API çš„ä¸åŒå±‚ä¹‹é—´åˆ’åˆ†èŒè´£ã€‚`PizzaOrderModule`çœ‹èµ·æ¥ä¼šåƒè¿™æ ·:

#### **`pizza-order.module.ts`T4ã€‘**

```
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { PizzaOrderResolver } from './pizza-order.resolver';
import { PizzaOrderService } from './pizza-order.service';
import { PizzaOrderSchema } from './schemas/pizza-order.schema';

/**
 * Mongoose automatically registers a Model based
 * on the provided Schema using the `forFeature`
 * method on the `MongooseModule`.
 */
@Module({
  imports: [
    MongooseModule.forFeature([
      {
        name: 'PizzaOrder',
        schema: PizzaOrderSchema,
        collection: 'pizza-orders'
      }
    ])
  ],
  providers: [PizzaOrderResolver, PizzaOrderService]
})
export class PizzaOrderModule {} 
```

ç°åœ¨æˆ‘ä»¬éœ€è¦æä¾›å®é™…çš„ GraphQL ç«¯ç‚¹ã€‚æˆ‘ä»¬é€šè¿‡å®šä¹‰æˆ‘ä»¬çš„ GraphQL è§£æå™¨æ¥åšåˆ°è¿™ä¸€ç‚¹:

#### **`pizza-order.resolver.ts`T4ã€‘**

```
import { Args, Mutation, Resolver } from '@nestjs/graphql';
import { User } from '@pizza-api/user/models/user.model';
import { CurrentUser } from '@pizza-api/user/decorators/current-user';
import { PizzaOrderInput } from './dto/pizza-order.input';
import { PizzaOrder } from './models/pizza-order.model';
import { PizzaOrderService } from './pizza-order.service';

/**
 * The GraphQL Resolver takes care of all resolver-related
 * responsibilities. It should therefore **never** perform
 * any database interactions directly.
 */
@Resolver(() => PizzaOrder)
export class PizzaOrderResolver {
  /**
   * We inject the `PizzaOrderService`, which is used to
   * interact with MongoDB through Mongoose.
   */
  constructor(private pizzaOrderService: PizzaOrderService) {}

  /**
   * The mutation that our API should perform, based
   * on the requirements.
   */
  @Mutation()
  public orderPizza(
    @CurrentUser() currUser: User,
    @Args() newOrder: PizzaOrderInput
  ) {
    /**
     * This seems like a good place for our requirements:
     *
     * 1\. Create a new order document in a `pizza-orders` collection.
     * 2\. Add an order reference to the requesting user document in a `users` collection.
     * 3\. The operations should be **causally consistent**.
     */
  }
} 
```

æœ€åï¼Œæˆ‘ä»¬æœ‰é€šè¿‡ Mongoose å¤„ç†æ•°æ®åº“äº¤äº’çš„æœåŠ¡:

#### **`pizza-order.service.ts`T4ã€‘**

```
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { UserService } from '@pizza-api/user/user.service';
import { Document, Model } from 'mongoose';
import { PizzaOrder } from './interfaces/pizza-order';
import { PizzaOrderInput } from './dto/pizza-order.input';

/**
 * The Service is used to provide a layer through which
 * database interactions ought to be performed. Results are
 * then passed back to the GraphQL Resolver for optional
 * further processing.
 */
@Injectable()
export class PizzaOrderService {
  /**
   * The injected `UserService` is used to perform
   * a mutation on the User's document for adding a
   * reference to a Pizza Order.
   */
  constructor(
    @InjectModel('PizzaOrder')
    private pizzaOrderModel: Model<PizzaOrder & Document>,
    private userService: UserService
  ) {}

  public createOrder(userId: string, newOrder: PizzaOrderInput) {
    /**
     * This is the place where the actual creation
     * of the document takes place:
     *
     * 1\. Create a new order document in a `pizza-orders` collection.
     */
  }

  public addOrderRefToUser(userId: string, orderId: string) {
    /**
     * This is where we add the order to the user:
     *
     * 2\. Add an order reference to the requesting user document in a `users` collection.
     */
  }
} 
```

## [](#nestjs-interceptors-amp-parameter-decorators)NestJS æ‹¦æˆªå™¨&å‚æ•°è£…é¥°å™¨

æ—¢ç„¶å·²ç»è®¾ç½®äº†æŠ«è¨è®¢å•åŠŸèƒ½ï¼Œæˆ‘ä»¬ç»§ç»­ä½¿ç”¨ NestJS æ‹¦æˆªå™¨å’Œå®šåˆ¶è£…é¥°å™¨ã€‚NestJS ä¸­çš„æ‹¦æˆªå™¨å—åˆ°äº†[é¢å‘æ–¹é¢ç¼–ç¨‹](https://en.wikipedia.org/wiki/Aspect-oriented_programming)æŠ€æœ¯çš„å¯å‘ã€‚ä½¿ç”¨æ‹¦æˆªå™¨çš„åŸå› ä¹‹ä¸€æ˜¯åœ¨æ–¹æ³•æ‰§è¡Œä¹‹å‰æˆ–ä¹‹åç»‘å®šé¢å¤–çš„é€»è¾‘ã€‚å½“æˆ‘ä»¬è€ƒè™‘æˆ‘ä»¬çš„éœ€æ±‚æ—¶ï¼Œæˆ‘ä»¬çœ‹åˆ°è¿™ä¸ªæ¦‚å¿µé€‚åˆæˆ‘ä»¬çš„ç”¨ä¾‹:

> æˆ‘ä»¬å¸Œæœ›åœ¨ GraphQL è§£æå™¨æ–¹æ³•æ‰§è¡Œä¹‹å‰å¼€å§‹ä¼šè¯ï¼Œåœ¨æ–¹æ³•æ‰§è¡Œä¹‹åç»“æŸä¼šè¯ã€‚

ä½¿ç”¨è¿™ç§æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥ä¸ºæ¯ä¸ªè¯·æ±‚åˆ›å»ºä¸€ä¸ªä¼šè¯ï¼Œå¹¶å°†å…¶ç”¨äºè¯¥è¯·æ±‚ä¸­çš„æ‰€æœ‰æ•°æ®åº“äº¤äº’ã€‚å› æ­¤ï¼Œç®¡ç†ä¼šè¯çš„è´£ä»»å°†è¢«åˆ†é…ç»™ GraphQL è§£æå™¨ã€‚æˆ‘ä»¬å°†æ‰©å±•æˆ‘ä»¬çš„æ–‡ä»¶ç»“æ„å¦‚ä¸‹:

```
ğŸ“ decorators/
  +-- mongo-session.decorator.ts
ğŸ“ interceptors/
  +-- mongo-session.interceptor.ts
ğŸ“ pizza-order/
  +-- ...
+-- app.module.ts 
```

è¿™å°±æŠŠæˆ‘ä»¬å¸¦åˆ°äº† NestJS æ‹¦æˆªå™¨çš„å®ç°:

#### **`mongo-session.interceptor.ts`T4ã€‘**

```
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor
} from '@nestjs/common';
import { GqlExecutionContext } from '@nestjs/graphql';
import { InjectConnection } from '@nestjs/mongoose';
import { Connection } from 'mongoose';
import { from, Observable, throwError } from 'rxjs';
import { catchError, mapTo, switchMap, tap } from 'rxjs/operators';

export const MONGO_SESSION_KEY = 'MONGO_SESSION_KEY';

@Injectable()
export class MongoSessionInterceptor implements NestInterceptor {
  /**
   * A Mongoose Connection is injected, so we can use
   * it to create and start a session.
   */
  constructor(@InjectConnection() private readonly connection: Connection) {}

  /**
   * The `intercept` method return a Promise, since we
   * are `await`-ing the `startSession` method on the
   * connection. The returned Promise holds an Observable
   * we use to pipe different operators together.
   */
  async intercept(
    context: ExecutionContext,
    next: CallHandler
  ): Promise<Observable<any>> {
    const graphQlCtx = GqlExecutionContext.create(context);
    const ctx = graphQlCtx.getContext();
    const session = await this.connection.startSession();

    /**
     * We assign the newly created session to the
     * the GraphQL context, which allows us to access
     * the session later on via a `Custom Decorator`.
     */
    ctx[MONGO_SESSION_KEY] = session;
    session.startTransaction();

    /**
     * A chain of RxJS Observables is used to `pipe` the
     * operations together. In the end, we either commit
     * or abort the transactions, followed by a final statement
     * to end the transaction. 
     */
    return next.handle().pipe(
      switchMap(data =>
        from(
          session.inTransaction()
            ? session.commitTransaction()
            : Promise.resolve()
        ).pipe(mapTo(data))
      ),
      tap(() => session.inTransaction() && session.endSession()),
      catchError(async err => {
        if (session.inTransaction()) {
          await session.abortTransaction();
          session.endSession();
        }

        throw err;
      })
    );
  }
} 
```

åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬æœ‰ä¸€äº›é‡è¦çš„æ­¥éª¤æ¥ä½¿æ‹¦æˆªå™¨æŒ‰ç…§é¢„æœŸçš„æ–¹å¼è¿è¡Œ:

*   `startSession()`æ–¹æ³•æ˜¯å¼‚æ­¥çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦åœ¨é‚£é‡Œä½¿ç”¨`await`ã€‚
*   ç”±äº`commitTransaction()`è¿”å›`void`ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ª`mapTo()`æ“ä½œç¬¦æ¥è¿”å›è¯·æ±‚ä¸­ä¼ é€’çš„å®é™…æ•°æ®ã€‚
*   `catchError()`å›è°ƒæ˜¯å¼‚æ­¥çš„ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦åœ¨`abortTransaction()`æ–¹æ³•è¿”å›ä¸€ä¸ª`Promise`æ—¶å¯¹å…¶è¿›è¡Œ`await`ã€‚
*   åœ¨`catchError()`æ“ä½œç¬¦çš„æœ«å°¾ï¼Œè¢«æ•è·çš„é”™è¯¯**è¢«å†æ¬¡æŠ›å‡º**ã€‚è¿™æ˜¯éœ€è¦æ³¨æ„çš„é‡è¦ä¸€ç‚¹ï¼Œå› ä¸ºæˆ‘ä»¬å¸Œæœ›æˆ‘ä»¬çš„æ‹¦æˆªå™¨éµå®ˆ[å•ä¸€è´£ä»»åŸåˆ™](https://en.wikipedia.org/wiki/Single_responsibility_principle) (SPR)ã€‚å› æ­¤ï¼Œä»»ä½•é”™è¯¯çš„è½¬æ¢æˆ–æ ¼å¼åŒ–éƒ½åº”è¯¥æ”¾åœ¨ä¸€ä¸ª(å¦ä¸€ä¸ª)ä¸“ç”¨çš„æ‹¦æˆªå™¨ä¸­ã€‚
*   æˆ‘ä»¬ç¡®ä¿ï¼Œåœ¨æäº¤æˆ–ä¸­æ­¢äº‹åŠ¡ä¹‹å‰ï¼Œæˆ‘ä»¬ä½¿ç”¨`inTransaction()`æ–¹æ³•æ£€æŸ¥ä¼šè¯æ˜¯å¦ç¡®å®åœ¨äº‹åŠ¡çš„*ä¸­ã€‚*

æˆ‘ä»¬ç°åœ¨éœ€è¦åšçš„æœ€åä¸€ä»¶äº‹æ˜¯å®ç°è‡ªå®šä¹‰è£…é¥°å™¨ï¼Œä»¥ä¾¿è®¿é—®æˆ‘ä»¬åœ¨`MongoSessionInterceptor`ä¸­åˆ›å»ºçš„ä¼šè¯ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦è®¿é—®æˆ‘ä»¬çš„ GraphQL è§£æå™¨ä¸­çš„ä¼šè¯ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¦‚ä¸‹å®ç°äº†`MongoSession`è£…é¥°å™¨:

#### **`mongo-session.decorator.ts`T4ã€‘**

```
import { createParamDecorator } from '@nestjs/common';
import { CustomParamFactory } from '@nestjs/common/interfaces';
import { GraphQLResolveInfo } from 'graphql';
import { MONGO_SESSION_KEY } from '../interceptors/mongo-session.interceptor';

export const mongoSessionFactory: CustomParamFactory = (
  data: any,
  [root, args, ctx, info]: [object, any, any, GraphQLResolveInfo]
) => ctx[MONGO_SESSION_KEY];

export const MongoSession = createParamDecorator(mongoSessionFactory); 
```

> æ‚¨å¯èƒ½ä¼šæ³¨æ„åˆ°ï¼Œä¸Šé¢çš„å·¥å‚ä¹Ÿå¯ä»¥ç›´æ¥åœ¨`createParamDecorator()`ä¸­å®ç°ï¼Œç„¶è€Œï¼Œè¿™ä¼šä½¿æµ‹è¯•å·¥å‚å˜å¾—æ›´åŠ å›°éš¾ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œå°†äºŒè€…åˆ†å¼€ã€‚

æˆ‘ä»¬ç°åœ¨å‡†å¤‡å¼€å§‹ä½¿ç”¨æˆ‘ä»¬åœ¨`PizzaOrderModule`å’Œ friends ä¸­çš„å®ç°ã€‚

# [](#usage)ç”¨æ³•

ç°åœ¨æˆ‘ä»¬å·²ç»æœ‰äº†å®¢æˆ·ç«¯ä½¿ç”¨çš„æ‰€æœ‰å®ç°ï¼Œæˆ‘ä»¬å¯ä»¥å¼€å§‹å‘ GraphQL è§£æå™¨æ·»åŠ æ‹¦æˆªå™¨å’Œå®šåˆ¶è£…é¥°å™¨äº†:

#### **`pizza-order.resolver.ts`T4ã€‘**

```
import { ClientSession } from 'mongoose';
import { MongoSession } from '../decorators/mongo-session.decorator';
// ...

@Resolver(() => PizzaOrder)
export class PizzaOrderResolver {

  // ...

  /**
   * We can now start using our `MongoSession` decorator
   * inside this endpoint and pass that `session` along
   * with our service calls.
   */
  @Mutation()
  public async orderPizza(
    @CurrentUser() currUser: User,
    @Args() newOrder: PizzaOrderInput,
    @MongoSession() session: ClientSession
  ) {
    const order = await this.pizzaOrderService.createOrder(currUser.id, newOrder, session);
    await this.pizzaOrderService.addOrderRefToUser(currUser.id, order.id);

    return { success: true };
  }
} 
```

ç°åœ¨éœ€è¦æ›´æ”¹æœåŠ¡æ–¹æ³•çš„ç­¾åï¼Œä»¥ä¾¿æ¥å—ä¼šè¯å‚æ•°ã€‚ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨è¯¥ä¼šè¯è¿›è¡Œè¿›ä¸€æ­¥çš„æ•°æ®åº“äº¤äº’:

```
// ...

@Injectable()
export class PizzaOrderService {

  // ...

  /**
   * We now use the `session` as an argument to
   * the `save()` method on a document. This ensures
   * that the operation becomes part of the current
   * transaction.
   */
  public createOrder(
    userId: string, 
    newOrder: PizzaOrderInput, 
    session: ClientSession
  ) {
    const doc = new this.pizzaOrderModel({
      ...newOrder,
      owner: userId
    });

    return doc.save({ session });
  }

  /**
   * The implementation of the `addPizzaOrderRef()` method
   * of the `UsersService` is left out for brevity here. You
   * can see that the `session` should also be used there, such
   * that the operation is added to the current session. Note
   * that sessions can be added using currying of Mongoose methods:
   *
   * @example
   *
   *   model
   *     .find()
   *     .session(session)
   */
  public addOrderRefToUser(
    userId: string, 
    orderId: string, 
    session: ClientSession
  ) {
    return this.usersService.addPizzaOrderRef(userId, orderId, session);
  }
} 
```

> å°†`addOrderRefToUser`æ–¹æ³•è®¾ä¸ºç§æœ‰å¹¶ä»`createOrder`å‡½æ•°ä½“å†…è°ƒç”¨å®ƒä¹Ÿæ˜¯éå¸¸å¥½çš„ã€‚è¿™å…è®¸`PizzaOrderResolver`åªå¯¹`PizzaOrderService`æ–¹æ³•`createOrder`è¿›è¡Œä¸€æ¬¡è°ƒç”¨ï¼Œè€Œæ²¡æœ‰ä»»ä½•é¢å¤–çš„è°ƒç”¨ã€‚è¯·è®°ä½ï¼Œä¸Šè¿°å®ç°æ˜¯ä¸ºäº†æ¼”ç¤ºçš„ç›®çš„ã€‚

# [](#conclusion)ç»“è®º

è¿™å°±ç»“æŸäº†æˆ‘ä»¬å¯¹**å› æœä¸€è‡´æ€§**çš„æ¢ç©¶ï¼Œä»¥åŠä¸€äº›ç”¨äºå®ç°çš„ä»£ç ç¤ºä¾‹ã€‚æ‚¨ç°åœ¨å·²ç»çœ‹åˆ°äº†:

*   **å› æœä¸€è‡´æ€§çš„æ¦‚å¿µ** *ç”±*ç»„æˆ(åŒå…³è¯­)
*   å¦‚ä½•ä»ä¸€ç»„éœ€æ±‚ä¸­è¯†åˆ«å› æœä¸€è‡´æ€§çš„éœ€è¦
*   å¦‚ä½•åœ¨ç°ä»£æŠ€æœ¯æ ˆä¸­å®ç°å› æœä¸€è‡´æ€§

æ„Ÿè°¢ä½ é˜…è¯»è¿™ç¯‡æ–‡ç« ã€‚å¸Œæœ›å®ƒèƒ½è®©ä½ æ”¹è¿›ä½ åœ¨èŠ‚ç‚¹ API ä¸Šçš„å¼€å‘ï¼Œæˆ–è€…ä»»ä½•è½¯ä»¶é¡¹ç›®ã€‚æ¬¢è¿åœ¨ä¸‹é¢ç•™ä¸‹ä»»ä½•é—®é¢˜æˆ–è¯„è®ºã€‚

æ‚¨ä¹Ÿå¯ä»¥åœ¨ Twitter ä¸Šå…³æ³¨æˆ‘